CHAPTER 5: MEMORY MANAGEMENT
5.1 Background
Memory is central to the operation of a modern computer system. It consists of a large array of bytes, each with its own address. The CPU fetches instructions from memory according to the value of the program counter. These instructions may cause additional loading from and storing to specific memory addresses.
5.1.1 Basic Hardware
To ensure system integrity, we must protect the operating system from user processes and user processes from one another. This protection is provided by the hardware in the form of Base and Limit Registers.
* Base Register: Holds the smallest legal physical memory address.
* Limit Register: Specifies the size of the range (e.g., if the base is 300040 and the limit is 120900, the program can legally access all addresses from 300040 through 420940).

5.2 Address Binding
Usually, a program resides on a disk as a binary executable file. To be executed, the program must be brought into memory and placed within a process.
* Logical Address: An address generated by the CPU (also called a virtual address).
* Physical Address: An address seen by the memory unit (the address loaded into the memory-address register).
The run-time mapping from virtual to physical addresses is done by a hardware device called the Memory-Management Unit (MMU).

5.3 Swapping
A process must be in memory to be executed. However, a process can be swapped temporarily out of memory to a backing store (typically a fast disk) and then brought back into memory for continued execution. Swapping makes it possible for the total physical address space of all processes to exceed the real physical memory of the system.

5.4 Contiguous Memory Allocation
In this early scheme, each process is contained in a single contiguous section of memory.
* Fixed Partitioning: Memory is divided into fixed-sized partitions. Each partition contains exactly one process.
* Variable Partitioning: The OS keeps a table indicating which parts of memory are available and which are occupied.
Fragmentation:
1. External Fragmentation: Total memory space exists to satisfy a request, but it is not contiguous.
2. Internal Fragmentation: Allocated memory may be slightly larger than requested memory (the difference is internal to the partition and wasted).

5.5 Paging
Paging is a memory-management scheme that eliminates the need for contiguous allocation of physical memory. This scheme avoids external fragmentation.
* Frames: Physical memory is broken into fixed-sized blocks.
* Pages: Logical memory is broken into blocks of the same size.
* Page Table: Every logical address generated by the CPU is divided into a Page Number ($p$) and a Page Offset ($d$). The page number is used as an index into a page table to find the corresponding base address of the frame in physical memory.

5.6 Segmentation
Segmentation is a memory-management scheme that supports the "user view" of memory. A logical address space is a collection of segments. Each segment has a name and a length. Addresses specify both the segment name and the offset within the segment (e.g., "segment 2, offset 50").

5.7 Virtual Memory
Virtual memory is a technique that allows the execution of processes that are not completely in memory. One major advantage of this scheme is that programs can be larger than physical memory.
5.7.1 Demand Paging
Rather than loading the entire program into memory at once, we use Demand Paging. A page is brought into memory only when it is needed during execution.
* Page Fault: Occurs when the process tries to access a page that was not brought into main memory. The OS must then find the page on the disk and load it into an empty frame.
5.7.2 Page Replacement Algorithms
When a page fault occurs and there are no free frames, the OS must decide which page to replace.
1. FIFO (First-In, First-Out): The oldest page is replaced.
2. Optimal: Replace the page that will not be used for the longest period of time (requires future knowledge).
3. LRU (Least Recently Used): Replace the page that has not been used for the longest period of time.

5.8 Thrashing
If a process does not have "enough" pages, the page-fault rate is very high. This leads to:
1. Low CPU utilization.
2. The OS thinking it needs to increase the degree of multiprogramming.
3. Another process added to the system, making the problem worse.
This high paging activity is called Thrashing. A system is thrashing if it is spending more time paging than executing.

